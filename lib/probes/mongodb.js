'use strict'

const shimmer = require('shimmer')
const ao = require('..')
const semver = require('semver')
const objectSanitizer = require('../object-sanitizer')

const conf = ao.probes.mongodb
const logMissing = ao.makeLogMissing('mongodb')

const requirePatch = require('../require-patch')

const prepQueryString = (obj) => {
  // conf is an external global
  return conf.sanitizeObject
    ? JSON.stringify(objectSanitizer.sanitize(obj))
    : JSON.stringify(obj)
}

// map possible commands to a function that generates their required KVs
// list is generated by running various commands and observing the passed object.
const commandKVs = {
  // sub of command or query

  // Databases
  dropDatabase: () => {
    return {
      QueryOp: 'drop'
    }
  },

  // Collections
  create: (cmd) => {
    return {
      QueryOp: 'create_collection',
      New_Collection_Name: cmd.create
    }
  },
  renameCollection: (cmd) => {
    return {
      QueryOp: 'rename',
      New_Collection_Name: cmd.to.slice(cmd.to.indexOf('.') + 1)
    }
  },
  dropCollection: () => {
    return {
      QueryOp: 'drop_collection'
    }
  },
  drop: () => {
    return {
      QueryOp: 'drop_collection'
    }
  },

  // Finding
  distinct: (cmd) => {
    return {
      QueryOp: 'distinct',
      Query: prepQueryString(cmd.query),
      Key: cmd.key
    }
  },
  find: (cmd) => {
    return {
      QueryOp: 'find',
      Query: prepQueryString(cmd.query || cmd.filter) // v3.x is query, 4.x is filter
    }
  },
  // will be called with findOneAndUpdate, findOneAndReplace or findOneAndDelete
  findAndModify: (cmd) => {
    const data = {
      QueryOp: 'find_and_modify',
      Query: prepQueryString(cmd.query)
    }
    // delete does not have a document
    if (cmd.update) {
      data.Update_Document = prepQueryString(cmd.update)
    }
    return data
  },
  count: (cmd) => {
    const data = {
      QueryOp: 'count'
    }
    // estimatedDocumentCount does not have a query
    if (cmd.query) {
      data.Query = prepQueryString(cmd.query)
    }
    return data
  },

  // Indexes
  createIndexes: (cmd) => {
    return {
      QueryOp: 'create_indexes',
      Indexes: prepQueryString(cmd.indexes)
    }
  },
  dropIndexes: (cmd) => {
    return {
      QueryOp: 'drop_indexes',
      Index: prepQueryString(cmd.index)
    }
  },
  deleteIndexes: (cmd) => {
    return {
      QueryOp: 'drop_indexes',
      Index: prepQueryString(cmd.index)
    }
  },
  reIndex: () => {
    return {
      QueryOp: 'reindex'
    }
  },

  // Aggregation
  group: (cmd) => {
    const data = {
      QueryOp: 'group',
      Group_Condition: prepQueryString(cmd.group.cond),
      Group_Initial: prepQueryString(cmd.group.initial),
      Group_Key: prepQueryString(cmd.group.key)
    }

    if (typeof cmd.group.$reduce === 'function') {
      data.Group_Reduce = cmd.group.$reduce.toString()
    } else if (typeof cmd.group.$reduce === 'object') {
      data.Group_Reduce = cmd.group.$reduce.code.toString()
    } else {
      data.Group_Reduce = cmd.group.$reduce.toString()
    }

    return data
  },
  mapReduce: (cmd) => {
    const data = {
      QueryOp: 'map_reduce',
      Map_Function: cmd.map,
      Reduce_Function: cmd.reduce
    }

    if (cmd.finalize) {
      data.Finalize_Function = cmd.finalize
    }

    return data
  },
  aggregate: (cmd) => {
    return {
      QueryOp: 'aggregate',
      Pipeline: prepQueryString(cmd.pipeline)
    }
  },

  // atomic commands in 3.x
  insert: (opsOrCmd) => {
    return {
      QueryOp: 'insert',
      Insert_Document: prepQueryString((opsOrCmd))
    }
  },
  update: (opsOrCmd) => {
    const obj = Array.isArray(opsOrCmd) ? opsOrCmd : opsOrCmd.updates
    return {
      QueryOp: 'update',
      Query: prepQueryString(obj.map(v => v.q)),
      Update_Document: prepQueryString(obj.map(v => v.u))
    }
  },
  remove: (opsOrCmd) => {
    const obj = Array.isArray(opsOrCmd) ? opsOrCmd : opsOrCmd.updates
    return {
      QueryOp: 'remove',
      Query: prepQueryString(obj.map(v => v.q))
    }
  },

  // deprecated but may still be used
  delete: (opsOrCmd) => {
    const obj = Array.isArray(opsOrCmd) ? opsOrCmd : opsOrCmd.deletes
    return {
      QueryOp: 'remove',
      Query: prepQueryString(obj.map(v => v.q))
    }
  }
}

module.exports = function (mongodb, options) {
  // v3.3.0 is the first version of mongodb that doesn't use mongodb-core.
  // v4.x.x has different signature
  if (semver.gte(options.version, '3.3.0') && semver.lt(options.version, '4.0.0')) {
    try {
      const coreWireProtocol = requirePatch.relReq('mongodb/lib/core/wireprotocol/index.js')

      Object.keys(coreWireProtocol).forEach((name) => {
        // for each of the operations
        shimmer.wrap(coreWireProtocol, name, fn => function wrappedCommand (...args) {
          // extract args
          let server, ns, cursorState, defaultOptions, callback, options, cmd, ops, batchSize
          // each operation has a different function signature
          /* eslint-disable no-unused-vars */
          if (name === 'query') {
            [server, ns, cmd, cursorState, options, callback] = args
          } else if (name === 'killCursors') {
            [server, ns, cursorState, defaultOptions, callback] = args
          } else if (name === 'getMore') {
            [server, ns, cursorState, batchSize, options, callback] = args
          } else if (name === 'command') {
            [server, ns, cmd, options, callback] = args
          } else {
            [server, ns, ops, options, callback] = args
          }
          /* eslint-enable no-unused-vars */

          // prep kv pairs
          // define default kvpairs
          const remoteHost =
                (server && server.description && server.description.address) ||
                (server && `${server.s && server.s.options && server.s.options.host}:${server.s && server.s.options && (server.s.options.port || 27017)}`) ||
                ''

          let kvpairs = {
            RemoteHost: remoteHost,
            Flavor: 'mongodb',
            Spec: 'query',
            QueryOp: 'command',
            Collection: ns.collection || '',
            Database: (typeof ns === 'string' && ns.split('.')[0]) || 'unknown'
          }

          if (name === 'command' || name === 'query') {
            // find sub command in the command kv definition object
            const subCommand = Object.keys(cmd).find(sub => commandKVs[sub])
            // execute the function to generate the kv object
            const specificKVs = subCommand ? commandKVs[subCommand](cmd) : {}
            // spread the command specific kvs into the default kvs.
            kvpairs = { ...kvpairs, ...specificKVs }
          }

          if (name === 'insert' || name === 'update' || name === 'remove') {
            // execute the function to generate the kv object
            const specificKVs = commandKVs[name](ops)
            // spread the command specific kvs into the default kvs.
            kvpairs = { ...kvpairs, ...specificKVs }
          }

          // remove callback from args
          args.pop()

          // instrument
          return ao.instrument(
            () => {
              return {
                name: 'mongodb',
                kvpairs
              }
            },
            done => fn.apply(this, args.concat(done)),
            conf,
            callback
          )
        })
      })
    } catch (e) {
      logMissing('lib/core/wireprotocol/index.js')
    }
  }

  if (semver.gte(options.version, '4.0.0')) {
    try {
      const connection = requirePatch.relReq('mongodb/lib/cmap/connection.js')
      const proto = connection.Connection.prototype

      // for each of the operations
      shimmer.wrap(proto, 'command', fn => function wrappedCommand (...args) {
        // extract args
        /* eslint-disable no-unused-vars */
        const [ns, cmd, options, callback] = args
        /* eslint-enable no-unused-vars */

        // define default kvpairs
        const remoteHost =
          (options && options.hostAddress && options.hostAddress.toString()) ||
          (options && options.session && options.session.client.s.url.replace('mongodb://', '')) ||
          ''

        let kvpairs = {
          RemoteHost: remoteHost || '',
          Flavor: 'mongodb',
          Spec: 'query',
          QueryOp: 'command',
          Collection: ns.collection || '',
          Database: ns.db || 'unknown'
        }

        // find sub command in the command kv definition object
        const subCommand = Object.keys(cmd).find(sub => commandKVs[sub])
        // execute the function to generate the kv object
        const specificKVs = subCommand ? commandKVs[subCommand](cmd) : {}
        // spread the command specific kvs into the default kvs.
        kvpairs = { ...kvpairs, ...specificKVs }

        // remove callback from args
        args.pop()

        // instrument
        return ao.instrument(
          () => {
            return {
              name: 'mongodb',
              kvpairs
            }
          },
          done => fn.apply(this, args.concat(done)),
          conf,
          callback
        )
      })
    } catch (e) {
      logMissing('lib/cmap/connection.js')
    }
  }

  return mongodb
}
